#logging:
#  level:
#    ROOT: DEBUG
#    org.springframework.cloud.gateway: DEBUG
eureka:
  client:
    service-url:
      #defaultZone: http://root:123456@127.0.0.1:8013/eureka
      defaultZone: http://127.0.0.1:8013/eureka
    #设为true，开启健康检查（需要sping-boot-start-actuator依赖）
    healthcheck:
      enabled: true
  instance:
    #使用ip替代实例名
    prefer-ip-address: true
spring:
  cloud:
    gateway:
      discovery:
        locator:
          # 路由时使用小写服务名
          #lower-case-service-id: true
          # 启用通过服务发现的路由
          enabled: true
      # 路由负载配置
      default-filters:
      routes:
        - id: test-service
          #eureka上的服务名
          uri: lb://LP-TEST-SERVICE
          predicates:
            - Path=/**
            - Weight=group1, 1
        #全局熔断降级配置
          filters:
            #StripPrefix=1
            - RewritePath=/employee/(?<path>.*), /$\{path}
            - name: Hystrix
              args:
                name: fallbackcmd
                fallbackUri: forward:/fallback

#        - id: test-service-1
#          #eureka上的服务名
#          uri: lb://LP-TEST-SERVICE
#          predicates:
#            - Path=/**
#           # - Weight=group1, 5
#          filters:
#            # 去掉/qa/ 比如访问url是/qa/test 经过gateway后，后面服务拿到的就只有/test
#            #StripPrefix=1
#            - RewritePath=/employee/(?<path>.*), /$\{path}
#            - name: Hystrix
#              args:
#                name: fallbackcmd
#                fallbackUri: forward:/fallback
#熔断时间
hystrix:
  command:
    default:
      execution:
        isolation:
          strategy:  SEMAPHORE
          thread:
            timeoutInMilliseconds: 300000  #熔断时间
management:
  endpoints:
    web:
      #      由于 Spring Boot 2.0 的 Actuator 只暴露了 /health、/info 两个端口（为了安全考虑）, 所以需要配置暴露的接口
      exposure:
        include: "*"
  endpoint:
    health:
      show-details: ALWAYS

    # test-service:
  #  ribbon:
    #   NFLoadBalancerPingClassName: com.cn.lp.qrcard.gateway.controller.HealthExamination
#    listOfServers: localhost:8021,localhost:8016
#    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule

#ribbon:
#  ReadTimeout: 3000 #服务请求处理超时时间（毫秒）
#  ConnectTimeout: 3000 #服务请求连接超时时间（毫秒）
#  OkToRetryOnAllOperations: true #对超时请求启用重试机制
#  MaxAutoRetriesNextServer: 1 #切换重试实例的最大个数
#  MaxAutoRetries: 1 # 切换实例后重试最大次数
#  NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule
  #  com.netflix.loadbalancer.RandomRule：从提供服务的实例中以随机的方式；
  #  com.netflix.loadbalancer.RoundRobinRule：以线性轮询的方式，就是维护一个计数器，从提供服务的实例中按顺序选取，第一次选第一个，第二次选第二个，以此类推，到最后一个以后再从头来过；
  #  com.netflix.loadbalancer.RetryRule：在RoundRobinRule的基础上添加重试机制，即在指定的重试时间内，反复使用线性轮询策略来选择可用实例；
  #  com.netflix.loadbalancer.WeightedResponseTimeRule：对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择；
  #  com.netflix.loadbalancer.BestAvailableRule：选择并发较小的实例；
  #  com.netflix.loadbalancer.AvailabilityFilteringRule：先过滤掉故障实例，再选择并发较小的实例；
  #  com.netflix.loadbalancer.ZoneAwareLoadBalancer：采用双重过滤，同时过滤不是同一区域的实例和故障实例，选择并发较小的实例。